# 데드락

Created Time: November 12, 2022 11:45 PM

![Untitled](%E1%84%83%E1%85%A6%E1%84%83%E1%85%B3%E1%84%85%E1%85%A1%E1%86%A8%20e5a607cbdc6747dbaec75acb8911c29f/Untitled.png)

위 이미지처럼 모든 차(프로세스)들이 직진을 하려고 한다.

직진을 하려면 각각의 차들이 |2,3|, |3,4|, |4,1|,|1,2| 의 리소스들을 가져가야 직진을 완수할 수 있다.

그런데 서로 다 직진을 하려다보니 리소스 하나씩(2,3,4,1)을 선점하는데에 성공은 했지만, 그 이후의 리소스들은 다른 차량들이 점유를 하고 있기 때문에 교착상태에 빠졌다.

그래서 모든 차량들이 오도가도 못하는 상황에 빠져버렸다.

이 상황이 매우 위험한 점이 해당 상황 이후에는 아무것도 진행할 수 없기 때문이다.

## Deadlock(교착상태)

두 개 이상의 프로세스 혹은 쓰레드가 **서로**가 가진 **리소스를 기다리는 상태**

### 데드락을 만드는 네 가지 조건

(여기서 리소스는 critical section, lock, CPU, Memory, SSD, Monitor , Printer 등 여러가지 포함)

1. Mutual exclision
    1. **리소스**를 **공유**해서 **사용할 수 없**다.
    2. 해당 리소스를 사용하려면 **한번의 하나**씩 **하나의 프로세스**만이 **사용 가능**하다.
    3. 공유를 하게 된다면 교통사고를 당한 것과 비슷한 맥락
2. Hold and Wait
    1. **프로세스**가 이미 **하나 이상**의 **리소스를 취득한(Hold) 상태**에서 **다른 프로세스**가 **사용**하고 있는 **리소스**를 추가로 **기다린다(Wait)**.
        1. 위 그림에서 (b)를 보면 모든 차량이 하나의 리소스를 점유하고 있다.
        2. 이 상태에서 2번 리소스를 점유한 차량은 3번 리소스를 기다리고 있는데, 3번 리소스가 이미 다른 차량에 의해서 사용이 되고있는 상태이다. 
        3. 이게 Hold and Wait
3. No preemption
    1. **리소스 반환(release)**은 오직 그 **리소스**를 **취득한 프로세스**만 할 수 있다.
        1. 2번 리소스를 취득한 차량의 리소스를 1번 리소스를 갖고 있는 차량이 뺏어갈 수 없다.
        2. 2번 리소스를 갖고 있는 차량이 2번 리소스를 반환해야지만 1번 리소스를 갖고 있는 차량이 이용 가능하다.
4. Circular wait
    1. 프로세스들이 **순환(Circular)** 형태로 **서로의 리소스**를 **기다린다**.
        1. 2번 리소스를 취득한 차량은 3번 리소스를 기다리고
        2. 3번 리소스를 취득한 차량은 4번 리소스를 기다리고
        3. 4번 리소스를 취득한 차량은 1번 리소스를 기다리고
        4. 1번 리소스를 취득한 차량은 2번 리소스를 기다리는 현상

위 4가지 조건을 전부 만족되면 데드락이 발생한다.

## OS의 데드락 해결 방법

아래처럼 4가지가 있는데 속 시원하게 해결할 수 있는 방법은 없다.

1. 데드락 방지(Deadlock prevention)
    1. 위의 데드락을 만드는 조건 4가지 중 하나가 충족되지 않게 시스템을 디자인
        1. mutual exclusion 방지
            1. **리소스를 공유** 가능하게 함
                1. 하지만 이것은 **현실적으로 불가능**하다.
                2. critical section에 진입하기 위해 락을 취득하는 개념이나
                3. 프린터기를 두 개의 프로세스가 동시에 사용하는 것이 불가능하다.(하나가 출력하면 그 출력이 끝날 때까지 대기해야한다.)
        2. hold and wait 방지
            1. 사용할 **리소스**들을 **모두 획득한 뒤**에 **시작**
            2. **리소스**를 **전혀 가지지 않은 상태**에서만 **리소스 요청**
                1. 2번 과 3번 리소스를 취득한 상황에서 2번 리소스를 가지고 오랜 시간 작업이 걸린다면, 그동안 3번 리소스는 놀고 있어 리소스 사용 효율이 떨어질 수 있다.
                2. 2번,3번 리소스가 다른 프로세스에서도 많이 이용하는 리소스라면 계속 기다리게 되는 현상(Starvation)이 일어날 수 있다. [기아 현상]
        3. no preemption 방지
            1. **추가적인 리소스**를 **기다려야 한다**면 이미 **획득한 리소스**를 **다른 프로세스가 선점 가능**하도록 한다.
                1. 2번 점유하고 있던 자동차가 3번을 리소스를 취득하기 위해 대기한다면 2번 리소스를 반환하여 다른 자동차가 이용하게 한다.
                2. 컨텍스트 스위칭처럼 점유하고 있다가 time slice를 다 사용하게 되면, 다음 프로세스에게 넘기는 것 처럼
                3. 모니터도 조건에 맞지 않으면 자기 자신의 락을 반환하는 것 처럼
                4. 전략이 비슷하다.
        4. circular wait
            1. 모든 리소스에 순서 체계를 부여해서 오름차순으로 리소스 요청
2. 데드락 회피
3. 데드락 감지와 복구
4. 데드락 무시