# 데드락

Created Time: November 12, 2022 11:45 PM

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/5246f345-55e3-493c-bbc4-4ae3de214d19/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221112%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221112T150024Z&X-Amz-Expires=86400&X-Amz-Signature=7af87d390201de50082c9e36142f3507f7cd4c003d6e35bd2b1fa56c63dea083&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22Untitled.png%22&x-id=GetObject)

위 이미지처럼 모든 차(프로세스)들이 직진을 하려고 한다.

직진을 하려면 각각의 차들이 |2,3|, |3,4|, |4,1|,|1,2| 의 리소스들을 가져가야 직진을 완수할 수 있다.

그런데 서로 다 직진을 하려다보니 리소스 하나씩(2,3,4,1)을 선점하는데에 성공은 했지만, 그 이후의 리소스들은 다른 차량들이 점유를 하고 있기 때문에 교착상태에 빠졌다.

그래서 모든 차량들이 오도가도 못하는 상황에 빠져버렸다.

이 상황이 매우 위험한 점이 해당 상황 이후에는 아무것도 진행할 수 없기 때문이다.

## Deadlock(교착상태)

두 개 이상의 프로세스 혹은 쓰레드가 **서로**가 가진 **리소스를 기다리는 상태**

### 데드락을 만드는 네 가지 조건

(여기서 리소스는 critical section, lock, CPU, Memory, SSD, Monitor , Printer 등 여러가지 포함)

1. Mutual exclision
    1. **리소스**를 **공유**해서 **사용할 수 없**다.
    2. 해당 리소스를 사용하려면 **한번의 하나**씩 **하나의 프로세스**만이 **사용 가능**하다.
    3. 공유를 하게 된다면 교통사고를 당한 것과 비슷한 맥락
2. Hold and Wait
    1. **프로세스**가 이미 **하나 이상**의 **리소스를 취득한(Hold) 상태**에서 **다른 프로세스**가 **사용**하고 있는 **리소스**를 추가로 **기다린다(Wait)**.
        1. 위 그림에서 (b)를 보면 모든 차량이 하나의 리소스를 점유하고 있다.
        2. 이 상태에서 2번 리소스를 점유한 차량은 3번 리소스를 기다리고 있는데, 3번 리소스가 이미 다른 차량에 의해서 사용이 되고있는 상태이다. 
        3. 이게 Hold and Wait
3. No preemption
    1. **리소스 반환(release)**은 오직 그 **리소스**를 **취득한 프로세스**만 할 수 있다.
        1. 2번 리소스를 취득한 차량의 리소스를 1번 리소스를 갖고 있는 차량이 뺏어갈 수 없다.
        2. 2번 리소스를 갖고 있는 차량이 2번 리소스를 반환해야지만 1번 리소스를 갖고 있는 차량이 이용 가능하다.
4. Circular wait
    1. 프로세스들이 **순환(Circular)** 형태로 **서로의 리소스**를 **기다린다**.
        1. 2번 리소스를 취득한 차량은 3번 리소스를 기다리고
        2. 3번 리소스를 취득한 차량은 4번 리소스를 기다리고
        3. 4번 리소스를 취득한 차량은 1번 리소스를 기다리고
        4. 1번 리소스를 취득한 차량은 2번 리소스를 기다리는 현상

위 4가지 조건을 전부 만족되면 데드락이 발생한다.

## OS의 데드락 해결 방법

아래처럼 4가지가 있는데 속 시원하게 해결할 수 있는 방법은 없다.

1. 데드락 방지(Deadlock prevention)
    1. 위의 데드락을 만드는 조건 4가지 중 하나가 충족되지 않게 시스템을 디자인
        1. mutual exclusion 방지
            1. **리소스를 공유** 가능하게 함
                1. 하지만 이것은 **현실적으로 불가능**하다.
                2. critical section에 진입하기 위해 락을 취득하는 개념이나
                3. 프린터기를 두 개의 프로세스가 동시에 사용하는 것이 불가능하다.(하나가 출력하면 그 출력이 끝날 때까지 대기해야한다.)
        2. hold and wait 방지
            1. 사용할 **리소스**들을 **모두 획득한 뒤**에 **시작**
            2. **리소스**를 **전혀 가지지 않은 상태**에서만 **리소스 요청**
                1. 2번 과 3번 리소스를 취득한 상황에서 2번 리소스를 가지고 오랜 시간 작업이 걸린다면, 그동안 3번 리소스는 놀고 있어 리소스 사용 효율이 떨어질 수 있다.
                2. 2번,3번 리소스가 다른 프로세스에서도 많이 이용하는 리소스라면 계속 기다리게 되는 현상(Starvation)이 일어날 수 있다. [기아 현상]
        3. no preemption 방지
            1. **추가적인 리소스**를 **기다려야 한다**면 이미 **획득한 리소스**를 **다른 프로세스가 선점 가능**하도록 한다.
                1. 2번 점유하고 있던 자동차가 3번을 리소스를 취득하기 위해 대기한다면 2번 리소스를 반환하여 다른 자동차가 이용하게 한다.
                2. 컨텍스트 스위칭처럼 점유하고 있다가 time slice를 다 사용하게 되면, 다음 프로세스에게 넘기는 것 처럼
                3. 모니터도 조건에 맞지 않으면 자기 자신의 락을 반환하는 것 처럼
                4. 전략이 비슷하다.
        4. circular wait
            1. **모든 리소스**에 **순서 체계**를 **부여**해서 **오름차순**으로 **리소스 요청**
                1. 4번 리소스를 확보한 차량이라면 현재 4번보다 큰 숫자인 리소스만 확보가 가능하다는 뜻이다.
                2. 4번 리소스를 확보한 뒤에는 1번 리소스를 확보할 수 없다.
                3. 4번 리소스 앞에 있는 차가 4번을 획득하려면 바로 4번을 획득할 수 없고, 우선 1번을 얻고나서 오름차순대로 4번을 획득할 수 있어서 circular wait이 방지가 된다.
                4. 데드락 방지를 위한 4가지 중 제일 많이 사용되는 방식
2. 데드락 회피(Deadlock avoidance)
    1. **실행 환경**에서 **추가적인 정보**(현재 사용 가능한 리소스들, 이미 누군가에게 할당된 리소스들, 미래에 있을 리소스 요청)를 활용해서 **데드락이 발생**할 것 같은 **상황을 회피**하는 것
    2. Banker algorithm
        1. **리소스 요청**을 허락해줬을 때 **데드락이 발생할 가능성**이 있으면, **리소스를 할당**해도 **안전할 때까지** 계속 **요청을 거절**하는 알고리즘
3. 데드락 감지와 복구
    1. **데드락을 허용**하고 **데드락**이 **발생**하면 **복구**하는 전략
    2. 복구 전략(이미 데드락이 발생한 상황)
        1. **프로세스**를 **종료**한다.
            1. 전체를 다 끄거나, 하나씩 끄면서 작동이 되는지 확인하며 종료
        2. **리소스**의 **일시**적인 **선점**을 **허용**
            1. 2번 리소스를 할당한 자동차가 1번 리소스를 할당한 자동차에게 2번 리소스를 할당해줌
4. 데드락 무시
    1. 데드락? 누구세요? 뭐 알아서 하겠죠~

## 프로그래밍 레벨에서의 데드락

### 자바

```java
public class Main {
	public static void main(String[] args) {
		Object lock1 = new Object();
		Object lock2 = new Object();

		Thread t1 = new Thread(() -> {
			synchronized (lock1) {
				System.out.println("[t1] get lock1");
				synchronized (lock2) {
					System.out.println("[t1] get lock2");
				}
			}
		});

		Thread t2 = new Thread(() -> {
			synchronized (lock2) {
				System.out.println("[t2] get lock2");
				synchronized (lock1) {
					System.out.println("[t2] get lock1");
				}
			}
		});

		t1.start();
		t2.start();
	}

}
```

`lock1`, `lock2` 리소스 두 개를 만들고, 쓰레드 `t1`, 쓰레드 `t2`를 실행시킨다.

`t1`은 `lock1`을 쥐려하고 취득시 `critical section`에 들어가고, `[t1] get lock1` 출력 후 두 번째 `critical section`에 진입하기 위해 `lock2`를 취득하려고 시도한다. 만약 성공하면 `[t1] get lock2` 출력을 한다.

`t2`는 `critical section`에 진입하기 위해 `lock2`를 취득하려 시도하고, 취득 시 `[t2] get lock2`

을 출력 후 두 번째 `critical section`에 진입하기 위해 `lock1`를 취득하려고 시도한다. 만약 성공하면 `[t2] get lock1` 출력을 한다.

보면은 t1은 lock1을 먼저 선점하려하고, t2는 lock2부터 선점하려한다.

문제는 그 다음부터인데 t1은 이제 lock2를 취득하려하고, t2는 lock1을 취득하려한다.

이 문제를 해결하기 위해선 여러가지 방법이 있다.

1. mutual exclusion이 정말 필요한가?(너무 남발한거 아닌가?)
    1. 무조건 필요하면 `t1`이던 `t2`이던 둘 중 `하나의 순서`를 `다른 하나의 쓰레드 순서`에 맞춘다.
        1. 이러면 circular wait 발생 안시킬 수 있다.
2. t1 이던 t2이던 구조가 |lock1 선점 후→ lock2| or |lock2 선점 후 → lock1| 이렇게 hold and wait 방식인데 이렇게 중첩이 필요한가?
    1. nested된 것을 밖으로 뺄 수 있으면 빼본다.

이처럼 데드락을 만드는 4가지 조건 중 하나라도 비틀면 해결할 수 있다.