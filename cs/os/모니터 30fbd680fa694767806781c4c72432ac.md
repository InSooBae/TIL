# 모니터

Created Time: October 29, 2022 2:51 PM
Status: 🛠 In Progress

## 모니터(Monitor)

- mutual exclusion을 보장
- 조건에 따라 쓰레드가 대기(waiting)상태로 전환 기능

### 모니터.. 언제 사용되나?

- 한번에 하나의 쓰레드만 실행돼야 할 때
- 여러 쓰레드와 협업(cooperation)이 필요할  때

### 모니터의 구성 요소

- mutex
    - critical section에서 mutual exclusion을 보장하는 장치
    - critical section에 진입하려면 mutex lock을 취득해야함
    - mutex lock을 취득하지 못한 쓰레드는 큐에 들어간 후 대기(waiting)상태로 전환
    - mutex lock을 쥔 쓰레드가 lock을 반환하면 락을 기다리며 큐에 대기상태로 있던 쓰레드 중 하나가 실행
- condition variable(s) → CV
    - waiting queue를 가짐
        - 조건이 충족되길 기다리는 쓰레드들이 대기 상태로 머무는 곳
    - wait
        - 쓰레드가 자기 자신을 CV의 waiting queue에 넣고 대기 상태로 전환
    - signal
        - waiting queue에서 대기중인 쓰레드 중 하나를 깨움
    - broadcast
        - waiting queue에서 대기중인 쓰레드 전부를 깨움

## 모니터 동작 방식

### 모니터 뼈대 코드

```cpp
acquire(m); // 모니터 락 취득

while (!p) { // 조건 확인
	wait(m, cv); // 조건 충족 안되면 waiting
}

...

signal(cv); -- or -- broadcast(cv2); // cv2rk cv와 같을 수 있음

release(m); // 모니터 락 반환
```

acquire(m) → 뮤텍스 락이 이미 다른 누군가가 점유하고 있다면, **entry queue**에서 대기한다.

release(m) → 점유하던 락을 반환하면 entry queue에 있는 대기 중이던 락을 깨우게 된다. 그리고 락이 아무도 취득하여 사용안하고 있기 때문에 critical section에 진입하여 코드 진행함

wait(m, cv) →  cv는 우선 나중에 생각하고 조건에 의해 wait을 실행시 **waiting queue**에 해당 락을 대기시킴. [대략적으로 cv로 인해 waiting queue 관리됨]

m의 mutex lock은 왜 들어가냐면, waiting 상태로 들어가게 되면 더 이상 락을 쥐고 있으면 안된다. 언제 깨어날 줄도 모르는데 락을 쥐고 있으면 다른 쓰레드들이 critical section에 진입할 수 없기에 해당 락은 반환이 되어야한다.(그리고 어떤 이유로 인해 다시 락을 취득 할 수 있어야 한다.)

signal(cv |cv2) → 하나를 깨울 때

boradcast(cv | cv2) → 기다리는 모든 것을 깨울 때

### 두 개의 큐(queue)

- entry queue: critical section에 진입을 기다리는 큐 (Mutex에서 관리하는 큐)
- waiting queue: 조건이 충족되길 기다리는 큐 (CV의 의해 관리되는 큐)

## Bounded Producer / Consumer Problem

![Producer&Consumer](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/f1e8be6e-8043-4148-bbdd-8b1675afa420/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221107%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221107T165721Z&X-Amz-Expires=86400&X-Amz-Signature=4c70287069dc81519312e71a2ef650c491a0108335324f5256d5c7aba0ba827c&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22Untitled.png%22&x-id=GetObject)

버퍼의 사이즈는 고정되어 있고, 왼쪽에 Producer 우측엔 Consumer가 보인다.

Producer는 Item을 생산해서 buffer에 넣고, Consumer는 Buffer에 있는 Item을 Consume을 하여 필요한 처리를 한다.

그러나 여기서 문제점이 있다.

`Producer`의 문제점 → `Producer`가 열심히 `Item`을 생산을 해서 그 `Item`을 `버퍼`에 다 집어넣었다.

`버퍼`가 가득차서 더 이상 들어갈 공간이 없는데도, `Producer`가 계속 `Item`을 생산하려 한다면 공간이 없기 때문에 넣을 수 없다. 그러면 `Producer`는 `Buffer`가 꽉찼는지 **계속 확인**해야 하는가?

`Consumer`의 문제점 → `Consumer`가 `버퍼`에서 `Item` 을 `Consume`하려 봤더니 `버퍼`에 아무런 `Item`이 없는 상황. `Consumer`는 계속해서 `Buffer`에 `Item`이 있는지 확인해야하는 것인가?

이런 두 가지 문제가 있다. 서로 **비슷하다는 느낌**이 들 것이고, 결론부터 말하면 이 문제는 `모니터`로 해결이 가능하다.

## Monitor Code Level

### global variable

```cpp
global volatile Buffer q;
global Lock lock;
global CV fullCV;
global CV emptyCV;
```

### producer()

```cpp
public method producer() {
	while (true) {
		Task myTask = ...;
		
		lock.acquire();
		
		while (q.isFull()) {
			wait(lock, fullCV);
		}

		q.enqueue(myTask);

		signal(emptyCV); -- or -- broadcast(emptyCV);

		lock.release();
	}
}
```

### consumer()

```cpp
public method consumer() {
	while (true) {
		lock.acquire();

		while (q.isEmpty()) {
			wait(lock, emptyCV);
		}

		myTask = q.dequeue();

		signal(fullCV); -- or -- broadcast(fullCV);

		lock.release();

		doStuff(myTask);
	}	
}
```
