# 모니터

Created Time: October 29, 2022 2:51 PM
Status: 🛠 In Progress

## 모니터(Monitor)

- mutual exclusion을 보장
- 조건에 따라 쓰레드가 대기(waiting)상태로 전환 기능

### 모니터.. 언제 사용되나?

- 한번에 하나의 쓰레드만 실행돼야 할 때
- 여러 쓰레드와 협업(cooperation)이 필요할  때

### 모니터의 구성 요소

- mutex
    - critical section에서 mutual exclusion을 보장하는 장치
    - critical section에 진입하려면 mutex lock을 취득해야함
    - mutex lock을 취득하지 못한 쓰레드는 큐에 들어간 후 대기(waiting)상태로 전환
    - mutex lock을 쥔 쓰레드가 lock을 반환하면 락을 기다리며 큐에 대기상태로 있던 쓰레드 중 하나가 실행
- condition variable(s) → CV
    - waiting queue를 가짐
        - 조건이 충족되길 기다리는 쓰레드들이 대기 상태로 머무는 곳
    - wait
        - 쓰레드가 자기 자신을 CV의 waiting queue에 넣고 대기 상태로 전환
    - signal
        - waiting queue에서 대기중인 쓰레드 중 하나를 깨움
    - broadcast
        - waiting queue에서 대기중인 쓰레드 전부를 깨움

## 모니터 동작 방식

### 모니터 뼈대 코드

```cpp
acquire(m); // 모니터 락 취득

while (!p) { // 조건 확인
	wait(m, cv); // 조건 충족 안되면 waiting
}

...

signal(cv); -- or -- broadcast(cv2); // cv2rk cv와 같을 수 있음

release(m); // 모니터 락 반환
```

acquire(m) → 뮤텍스 락이 이미 다른 누군가가 점유하고 있다면, **entry queue**에서 대기한다.

release(m) → 점유하던 락을 반환하면 entry queue에 있는 대기 중이던 락을 깨우게 된다. 그리고 락이 아무도 취득하여 사용안하고 있기 때문에 critical section에 진입하여 코드 진행함

wait(m, cv) →  cv는 우선 나중에 생각하고 조건에 의해 wait을 실행시 **waiting queue**에 해당 락을 대기시킴. [대략적으로 cv로 인해 waiting queue 관리됨]

m의 mutex lock은 왜 들어가냐면, waiting 상태로 들어가게 되면 더 이상 락을 쥐고 있으면 안된다. 언제 깨어날 줄도 모르는데 락을 쥐고 있으면 다른 쓰레드들이 critical section에 진입할 수 없기에 해당 락은 반환이 되어야한다.(그리고 어떤 이유로 인해 다시 락을 취득 할 수 있어야 한다.)

signal(cv |cv2) 

boradcast(cv | cv2)