# 스핀락, 뮤텍스, 세마포어

Created Time: October 19, 2022 11:30 PM
Status: 🛠 In Progress

## 어떻게 Mutual Exclusion을 보장할 수 있을까?

락(lock)을 사용하자

```java
do {

	acquire lock
		critical section
	release lock
		remainder section

} while (true)
```

여러 프로세스/쓰레드가 락을 획득하기 위해서 경합을 하게 되는데, 그 중 성공한 하나의 프로세스/쓰레드가 `critical section`에 들어가서 실행을 하게 된다.

해당 작업이 끝나면 `critical section`을 빠져나오면서 락을 반환한다.

```c
volatile int lock = 0; // global

int test_and_set(int* lockPtr);

void critical() {
	while (test_and_set(&lock) == 1);

	... critical section

	lock = 0;
}

int test_and_set(int* lockPtr) {
	int oldLock = *lockPtr;
	*lockPtr = 1;
	return oldLock;
}
```

2개의 쓰레드 T1, T2가 있다고 가정하고, critical()을 실행한다.

`while (test_and_set(&lock) == 1);` T1이 실행 후 `lock`이 1이 된 후 0을 리턴하여 while 루프를 탈출하고 `critical section`에 진입한다.

그 다음 T2가 실행되어 `while (test_and_set(&lock) == 1);` 에 진입하면 1에서 1로 바꿔주어 while 루프를 계속 test_and_set을 호출하며 반복하게 된다.

그러다가 T1의 `criitical section`에서 작업하던 것이 완료 후 `lock=0` 으로 바꿔주어 T2가 탈출후 진행하게 될 것이다.

이런 식으로 `TestAndSet`으로 동시에 `critical section`에서는 실행할 수 없게 된다.

그런데 동시에 `while (test_and_set(&lock) == 1);` 에 T1 T2가 실행을 한다면?

둘 다 진입할 수 있는 것이 아닌가?

이를 방지 가능하게끔 설계가 되어있다.

CPU의 도움을 받아 `TestAndSet`은 **CPU atomic** 명령어이다.

### CPU atomic

- 실행 중간에 간섭받거나 중단되지 않는다.
- 같은 메모리 영영에 대해 동시에 실행되지 않는다.
    - TestAndSet의 동일한 파라미터의 대해서 두 개 이상의 프로세스/쓰레드가 동시에 호출한다 할지라도, CPU 레벨에서 알아서 먼저 하나를 실행시키고 그 하나가 끝나면 다음이 실행되는 식으로 동기화 작업 처리를 함(동시에 실행 X)

다시 아까 예제의 `while (test_and_set(&lock) == 1);` 를 보면 test_and_set을 실행하고 있다가, C-S이 일어나지 않는다는 것이다. (다른 쓰레드가 실행될 일이 없음) atomic 하다.

두 개의 쓰레드가 동시에 test_and_set을 실행시키면 동시에 실행되지 않고 CPU 레벨에 둘 중에 하나가 실행되고(무엇이 먼저인지는 모름) 그 하나가 끝나면 다음 하나가 알아서 실행될 수 있도록 동기화를 시켜서 동시에 실행되는 일이 없도록 한다.

## 스핀락(Spinlock)

위 예제처럼 `while (test_and_set(&lock) == 1);` 락을 계속 얻으려고 반복해서 시도하는 방식이 스핀락이다.

하지만 기다리는 동안 CPU를 낭비한다는 단점이 있다.

(계속 락이 있는지 확인해야하니까 확인하는 자체가 CPU Cycle를 잡아먹음)

해결

락이 준비되면 나 깨워줘!! 그때동안 나 자고있을게!!